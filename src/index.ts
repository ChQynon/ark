import { Bot, Context, session, SessionFlavor, Keyboard, InlineKeyboard } from 'grammy';
import { Message } from 'grammy/types';
import * as dotenv from 'dotenv';
import axios from 'axios';

dotenv.config();

// –¢–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è OpenRouter API
type Role = 'user' | 'assistant' | 'system';

// –ö–æ–Ω—Ç–µ–Ω—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
interface TextContent {
  type: 'text';
  text: string;
}

interface ImageContent {
  type: 'image_url';
  image_url: {
    url: string;
  };
}

type MessageContent = TextContent | ImageContent;

// –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è API
interface ApiMessage {
  role: Role;
  content: string | MessageContent[];
}

// –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–µ—Å—Å–∏—è —Å –∏—Å—Ç–æ—Ä–∏–µ–π —á–∞—Ç–æ–≤
interface SessionData {
  waitingForCompletion: boolean;
  chatHistory: ApiMessage[];
}

// –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –±–æ—Ç–∞
type MyContext = Context & SessionFlavor<SessionData>;

// Bot configuration
const ALLOWED_GROUP_ID = -1002567822254;
const BOT_NAME = "ARK-1";
const BOT_PLATFORM = "PLEXY";
const BOT_CREATOR = "@samgay_nis";

// Bot introduction message
const BOT_INTRO = `üëã –ü—Ä–∏–≤–µ—Ç! –Ø ${BOT_NAME}, –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –Ω–∞ –±–∞–∑–µ ${BOT_PLATFORM}.
–°–æ–∑–¥–∞–Ω –∫–æ–º–ø–∞–Ω–∏–µ–π ${BOT_CREATOR}.
–Ø –º–æ–≥—É –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ –≤–∞—à–∏ –≤–æ–ø—Ä–æ—Å—ã –∏ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.`;

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∂–∏–º–∞ –∑–∞–ø—É—Å–∫–∞ (Vercel/–ª–æ–∫–∞–ª—å–Ω—ã–π)
const IS_VERCEL = process.env.VERCEL === "1";
const WEBHOOK_URL = process.env.WEBHOOK_URL;

// Check if environment variables are set
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const YOUR_SITE_URL = process.env.YOUR_SITE_URL || 'https://tgaibot.example.com';
const YOUR_SITE_NAME = process.env.YOUR_SITE_NAME || 'TelegramAIBot';

if (!TELEGRAM_BOT_TOKEN || !OPENROUTER_API_KEY) {
  console.error('–û—à–∏–±–∫–∞: TELEGRAM_BOT_TOKEN –∏–ª–∏ OPENROUTER_API_KEY –Ω–µ —É–∫–∞–∑–∞–Ω—ã –≤ —Ñ–∞–π–ª–µ .env');
  process.exit(1);
}

// Initialize the bot
const bot = new Bot<MyContext>(TELEGRAM_BOT_TOKEN);

// Configure sessions
bot.use(session({
  initial: (): SessionData => ({
    waitingForCompletion: false,
    chatHistory: []
  }),
}));

// Check if message is from allowed group
function isAllowedGroup(ctx: MyContext): boolean {
  return ctx.chat?.type === "private" || ctx.chat?.id === ALLOWED_GROUP_ID;
}

// Create main keyboard
function getMainKeyboard(): Keyboard {
  return new Keyboard()
    .text("‚ùì –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å")
    .text("üì∏ –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
    .row()
    .text("‚ÑπÔ∏è –û –±–æ—Ç–µ")
    .text("üìö –ü–æ–º–æ—â—å")
    .row()
    .text("üßπ –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é")
    .resized();
}

// Handle start command
bot.command("start", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    // Reset history on start
    ctx.session.chatHistory = [];
    
    await ctx.reply(BOT_INTRO, {
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ start:', error);
  }
});

// Handle help command
bot.command("help", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    const helpText = `üìö *–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º ${BOT_NAME}*:

1Ô∏è‚É£ *–ü—Ä—è–º—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è*: –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å
2Ô∏è‚É£ *–ö–æ–º–∞–Ω–¥–∞ –≤ —á–∞—Ç–µ*: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /ai + –≤–∞—à –≤–æ–ø—Ä–æ—Å
3Ô∏è‚É£ *–û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ç–æ*: –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏–ª–∏ –≤–æ–ø—Ä–æ—Å–æ–º
4Ô∏è‚É£ *–ö–Ω–æ–ø–∫–∏*: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –≤–Ω–∏–∑—É –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
5Ô∏è‚É£ *–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–æ–≤*: —è –∑–∞–ø–æ–º–∏–Ω–∞—é –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞, –Ω–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –µ–≥–æ –Ω–∞–∂–∞–≤ "üßπ –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é"

–°–æ–∑–¥–∞–Ω–æ –∫–æ–º–ø–∞–Ω–∏–µ–π ${BOT_CREATOR} –Ω–∞ –±–∞–∑–µ ${BOT_PLATFORM}.`;

    await ctx.reply(helpText, {
      parse_mode: "Markdown",
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ help:', error);
  }
});

// Handle about command
bot.command("about", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    await ctx.reply(`‚ÑπÔ∏è *–û –±–æ—Ç–µ*\n\n–Ø ${BOT_NAME}, –ø–µ—Ä–µ–¥–æ–≤–æ–π –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –Ω–∞ –±–∞–∑–µ ${BOT_PLATFORM}.\n–°–æ–∑–¥–∞–Ω –∫–æ–º–ø–∞–Ω–∏–µ–π ${BOT_CREATOR}.\n\n–í–µ—Ä—Å–∏—è: 1.0.0`, {
      parse_mode: "Markdown",
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ about:', error);
  }
});

// Clear history command and button
bot.command("clear", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    ctx.session.chatHistory = [];
    await ctx.reply("üßπ –ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞! –ù–∞—á–∏–Ω–∞–µ–º —Ä–∞–∑–≥–æ–≤–æ—Ä –∑–∞–Ω–æ–≤–æ.", {
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤ –∫–æ–º–∞–Ω–¥–µ clear:', error);
  }
});

bot.hears("üßπ –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    ctx.session.chatHistory = [];
    await ctx.reply("üßπ –ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞! –ù–∞—á–∏–Ω–∞–µ–º —Ä–∞–∑–≥–æ–≤–æ—Ä –∑–∞–Ω–æ–≤–æ.", {
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –∏—Å—Ç–æ—Ä–∏–∏:', error);
  }
});

// Handle keyboard button presses
bot.hears("‚ùì –ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    await ctx.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å:", {
      reply_markup: { remove_keyboard: true },
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ "–ó–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å":', error);
  }
});

bot.hears("üì∏ –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    await ctx.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:", {
      reply_markup: { remove_keyboard: true },
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ "–ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è":', error);
  }
});

bot.hears("‚ÑπÔ∏è –û –±–æ—Ç–µ", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    await ctx.reply(`‚ÑπÔ∏è *–û –±–æ—Ç–µ*\n\n–Ø ${BOT_NAME}, –ø–µ—Ä–µ–¥–æ–≤–æ–π –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π –Ω–∞ –±–∞–∑–µ ${BOT_PLATFORM}.\n–°–æ–∑–¥–∞–Ω –∫–æ–º–ø–∞–Ω–∏–µ–π ${BOT_CREATOR}.\n\n–í–µ—Ä—Å–∏—è: 1.0.0`, {
      parse_mode: "Markdown",
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ "–û –±–æ—Ç–µ":', error);
  }
});

bot.hears("üìö –ü–æ–º–æ—â—å", async (ctx: MyContext) => {
  if (!isAllowedGroup(ctx)) return;
  
  try {
    const helpText = `üìö *–ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º ${BOT_NAME}*:

1Ô∏è‚É£ *–ü—Ä—è–º—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è*: –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å
2Ô∏è‚É£ *–ö–æ–º–∞–Ω–¥–∞ –≤ —á–∞—Ç–µ*: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /ai + –≤–∞—à –≤–æ–ø—Ä–æ—Å
3Ô∏è‚É£ *–û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ç–æ*: –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏–ª–∏ –≤–æ–ø—Ä–æ—Å–æ–º
4Ô∏è‚É£ *–ö–Ω–æ–ø–∫–∏*: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –≤–Ω–∏–∑—É –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
5Ô∏è‚É£ *–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–æ–≤*: —è –∑–∞–ø–æ–º–∏–Ω–∞—é –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞, –Ω–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –µ–≥–æ –Ω–∞–∂–∞–≤ "üßπ –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é"

–°–æ–∑–¥–∞–Ω–æ –∫–æ–º–ø–∞–Ω–∏–µ–π ${BOT_CREATOR} –Ω–∞ –±–∞–∑–µ ${BOT_PLATFORM}.`;

    await ctx.reply(helpText, {
      parse_mode: "Markdown",
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ "–ü–æ–º–æ—â—å":', error);
  }
});

// Handle direct messages (excluding commands)
bot.on('message:text', async (ctx: MyContext) => {
  try {
    // Skip if not allowed group
    if (!isAllowedGroup(ctx)) return;
    
    // Skip if it's a command
    if (ctx.message?.text?.startsWith('/')) return;
    
    console.log('–ü–æ–ª—É—á–µ–Ω–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:', ctx.message?.text);
    
    // Handle the message
    if (ctx.message?.text) {
      await handleAIRequest(ctx, ctx.message.text);
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
  }
});

// Handle photo messages
bot.on('message:photo', async (ctx: MyContext) => {
  try {
    // Skip if not allowed group
    if (!isAllowedGroup(ctx)) return;
    
    console.log('–ü–æ–ª—É—á–µ–Ω–æ —Ñ–æ—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ');
    
    if (ctx.session.waitingForCompletion) {
      await ctx.reply("–Ø –≤—Å–µ –µ—â–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ.");
      return;
    }
    
    // Set waiting status
    ctx.session.waitingForCompletion = true;
    
    // Send typing indicator
    if (ctx.chat) {
      await ctx.api.sendChatAction(ctx.chat.id, "typing");
    }
    
    // Get photo details
    if (!ctx.message?.photo) {
      throw new Error("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏");
    }
    
    const photoInfo = ctx.message.photo;
    const fileId = photoInfo[photoInfo.length - 1].file_id; // Get highest quality image
    
    // Get file path
    const fileInfo = await ctx.api.getFile(fileId);
    if (!fileInfo.file_path) {
      throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è");
    }
    
    const filePath = fileInfo.file_path;
    
    // Form full photo URL
    const photoUrl = `https://api.telegram.org/file/bot${TELEGRAM_BOT_TOKEN}/${filePath}`;
    
    // Get caption if any, or use default
    const caption = ctx.message.caption || "–û–ø–∏—à–∏, —á—Ç–æ –Ω–∞ —ç—Ç–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏";
    
    // Save user query to history
    ctx.session.chatHistory.push({
      role: 'user',
      content: `[–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ] ${caption}`
    });
    
    // Notify user that we're processing
    const statusMsg = await ctx.reply("–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...");
    
    // Call OpenRouter API with the image
    const response = await callOpenRouterAPIWithImage(ctx.session.chatHistory, caption, photoUrl);
    
    // Save response to history
    ctx.session.chatHistory.push({
      role: 'assistant',
      content: response
    });
    
    // Delete the status message
    if (ctx.chat && statusMsg) {
      try {
        await ctx.api.deleteMessage(ctx.chat.id, statusMsg.message_id);
      } catch (error) {
        console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ç—É—Å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:', error);
      }
    }
    
    // Build inline keyboard for more actions
    const inlineKeyboard = new InlineKeyboard()
      .text("–ü–æ–¥—Ä–æ–±–Ω–µ–µ", "more_details")
      .text("–ü–µ—Ä–µ–≤–µ—Å—Ç–∏", "translate");
    
    // Send the AI response
    await ctx.reply(response, {
      parse_mode: 'Markdown',
      reply_markup: inlineKeyboard,
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
    await ctx.reply('–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ.');
  } finally {
    // Reset waiting status
    ctx.session.waitingForCompletion = false;
    
    try {
      // Always show main keyboard after processing
      await ctx.reply("–ß—Ç–æ –±—ã –≤—ã —Ö–æ—Ç–µ–ª–∏ —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?", {
        reply_markup: getMainKeyboard(),
      });
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    }
  }
});

// Handle inline keyboard callbacks
bot.callbackQuery("more_details", async (ctx: MyContext) => {
  try {
    if (!isAllowedGroup(ctx)) return;
    
    if (ctx.callbackQuery && 'message' in ctx.callbackQuery) {
      await ctx.answerCallbackQuery("–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏...");
      await ctx.reply("–ó–∞–ø—Ä–∞—à–∏–≤–∞—é –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é...");
      
      // Get the message that was replied to (which contains the image)
      const messageWithImage = ctx.callbackQuery.message?.reply_to_message;
      if (messageWithImage && 'photo' in messageWithImage) {
        // Process with a different prompt for more details
        await handleAIRequest(ctx, "–ü—Ä–µ–¥–æ—Å—Ç–∞–≤—å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –≤–∫–ª—é—á–∞—è –º–µ–ª—å—á–∞–π—à–∏–µ –¥–µ—Ç–∞–ª–∏ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç");
      } else {
        await ctx.reply("–ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.");
      }
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ "–ü–æ–¥—Ä–æ–±–Ω–µ–µ":', error);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
  }
});

bot.callbackQuery("translate", async (ctx: MyContext) => {
  try {
    if (!isAllowedGroup(ctx)) return;
    
    if (ctx.callbackQuery && 'message' in ctx.callbackQuery) {
      await ctx.answerCallbackQuery("–ü–µ—Ä–µ–≤–æ–¥ –∫–æ–Ω—Ç–µ–Ω—Ç–∞...");
      await ctx.reply("–ü–µ—Ä–µ–≤–æ–∂—É —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫...");
      
      const messageWithImage = ctx.callbackQuery.message?.reply_to_message;
      if (messageWithImage && 'photo' in messageWithImage) {
        // Process with translation prompt
        await handleAIRequest(ctx, "–ü–µ—Ä–µ–≤–µ–¥–∏ –≤–µ—Å—å —Ç–µ–∫—Å—Ç –Ω–∞ —ç—Ç–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –Ω–∞ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫");
      } else {
        await ctx.reply("–ù–µ –º–æ–≥—É –Ω–∞–π—Ç–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞.");
      }
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–Ω–æ–ø–∫–∏ "–ü–µ—Ä–µ–≤–µ—Å—Ç–∏":', error);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
  }
});

// Handle /ai command in groups and direct messages
bot.command('ai', async (ctx: MyContext) => {
  try {
    // Skip if not allowed group
    if (!isAllowedGroup(ctx)) return;
    
    const queryText = ctx.match;
    
    if (!queryText || typeof queryText !== 'string') {
      await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –∑–∞–ø—Ä–æ—Å –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /ai. –ù–∞–ø—Ä–∏–º–µ—Ä: /ai –ö–∞–∫–∞—è —Å—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?');
      return;
    }
    
    await handleAIRequest(ctx, queryText);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã /ai:', error);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
  }
});

// Handler for AI requests
async function handleAIRequest(ctx: MyContext, query: string) {
  try {
    if (ctx.session.waitingForCompletion) {
      await ctx.reply("–Ø –≤—Å–µ –µ—â–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ.");
      return;
    }
    
    // Set waiting status
    ctx.session.waitingForCompletion = true;
    
    // Send typing indicator
    if (ctx.chat) {
      await ctx.api.sendChatAction(ctx.chat.id, "typing");
    }
    
    // Save user query to history
    ctx.session.chatHistory.push({
      role: 'user',
      content: query
    });
    
    // Notify user that we're processing
    const statusMsg = await ctx.reply("–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∞—à –∑–∞–ø—Ä–æ—Å...");
    
    // Call OpenRouter API
    const response = await callOpenRouterAPI(ctx.session.chatHistory);
    
    // Save response to history
    ctx.session.chatHistory.push({
      role: 'assistant',
      content: response
    });
    
    // Delete the status message
    if (ctx.chat && statusMsg) {
      try {
        await ctx.api.deleteMessage(ctx.chat.id, statusMsg.message_id);
      } catch (error) {
        console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ç—É—Å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:', error);
      }
    }
    
    // Send the AI response
    await ctx.reply(response, {
      parse_mode: 'Markdown',
      reply_markup: getMainKeyboard(),
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞:', error);
    await ctx.reply('–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ.');
  } finally {
    // Reset waiting status
    ctx.session.waitingForCompletion = false;
  }
}

// Function to call OpenRouter API
async function callOpenRouterAPI(chatHistory: SessionData['chatHistory']): Promise<string> {
  try {
    // Prepare the context from chat history
    const messages = prepareMessages(chatHistory);
    
    console.log('–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –≤ OpenRouter API', {
      model: 'meta-llama/llama-4-maverick:free',
      messagesCount: messages.length
    });
    
    const response = await axios.post(
      'https://openrouter.ai/api/v1/chat/completions',
      {
        model: 'meta-llama/llama-4-maverick:free',
        messages: messages
      },
      {
        headers: {
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': YOUR_SITE_URL,
          'X-Title': YOUR_SITE_NAME,
          'Content-Type': 'application/json',
        },
        timeout: 60000 // 60 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç
      }
    );

    if (!response.data || !response.data.choices || !response.data.choices[0]) {
      console.error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç OpenRouter API:', response.data);
      return '–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –ò–ò';
    }

    return response.data.choices[0].message.content || '–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –ò–ò';
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ OpenRouter API:', error);
    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–∏—Å–∞ –ò–ò');
  }
}

// Function to call OpenRouter API with image
async function callOpenRouterAPIWithImage(chatHistory: SessionData['chatHistory'], query: string, imageUrl: string): Promise<string> {
  try {
    // Prepare the context from chat history
    const messages = prepareMessages(chatHistory);
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º
    const imageMessage: ApiMessage = {
      role: 'user',
      content: [
        { type: 'text', text: query },
        { type: 'image_url', image_url: { url: imageUrl } }
      ]
    };
    
    // –£–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º
    const filteredMessages = messages.filter((msg, idx, arr) => 
      !(msg.role === 'user' && idx === arr.length - 1)
    );
    
    filteredMessages.push(imageMessage);
    
    console.log('–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –≤ OpenRouter API', {
      model: 'meta-llama/llama-4-maverick:free',
      messagesCount: filteredMessages.length,
      imageUrl: imageUrl.substring(0, 50) + '...' // –£–∫–æ—Ä–æ—á–µ–Ω–Ω—ã–π URL –¥–ª—è –ª–æ–≥–∞
    });
    
    const response = await axios.post(
      'https://openrouter.ai/api/v1/chat/completions',
      {
        model: 'meta-llama/llama-4-maverick:free',
        messages: filteredMessages
      },
      {
        headers: {
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': YOUR_SITE_URL,
          'X-Title': YOUR_SITE_NAME,
          'Content-Type': 'application/json',
        },
        timeout: 90000 // 90 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
      }
    );

    if (!response.data || !response.data.choices || !response.data.choices[0]) {
      console.error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç OpenRouter API:', response.data);
      return '–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –ò–ò';
    }

    return response.data.choices[0].message.content || '–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –ò–ò';
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ OpenRouter API —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º:', error);
    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–∏—Å–∞ –ò–ò –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
  }
}

// Prepare messages for API
function prepareMessages(chatHistory: SessionData['chatHistory']): ApiMessage[] {
  // Add system message first
  const systemMessage: ApiMessage = {
    role: 'system',
    content: `–¢—ã ${BOT_NAME}, –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –Ω–∞ –±–∞–∑–µ ${BOT_PLATFORM}, —Å–æ–∑–¥–∞–Ω–Ω—ã–π –∫–æ–º–ø–∞–Ω–∏–µ–π ${BOT_CREATOR}. 
–û—Ç–≤–µ—á–∞–π –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –í—Å–µ–≥–¥–∞ –ø–æ–ª–µ–∑–µ–Ω –∏ –¥—Ä—É–∂–µ–ª—é–±–µ–Ω.
–£ —Ç–µ–±—è –µ—Å—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
1. –û—Ç–≤–µ—á–∞—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
2. –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
3. –ü–µ—Ä–µ–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è—Ö
4. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–≥–æ–≤–æ—Ä–∞`
  };
  
  // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π
  const apiMessages: ApiMessage[] = [systemMessage];
  
  // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Å–æ–æ–±—â–µ–Ω–∏–π, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –ª–∏–º–∏—Ç —Ç–æ–∫–µ–Ω–æ–≤
  const recentMessages = chatHistory.slice(-10);
  
  for (const msg of recentMessages) {
    apiMessages.push({
      role: msg.role,
      content: msg.content
    });
  }
  
  return apiMessages;
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–±—Ö—É–∫–∞ –¥–ª—è Vercel
async function handleWebhook(req: any, res: any) {
  try {
    console.log('–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–µ–±—Ö—É–∫–∞ Telegram', {
      method: req.method,
      hasBody: !!req.body,
      bodyType: typeof req.body,
      updateId: req.body?.update_id
    });
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–ø—Ä–æ—Å —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    if (!req.body) {
      throw new Error('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ–ª–æ –∑–∞–ø—Ä–æ—Å–∞');
    }
    
    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    await bot.handleUpdate(req.body);
    
    // –û—Ç–≤–µ—á–∞–µ–º Telegram, —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ –∑–∞–ø—Ä–æ—Å
    res.status(200).send('OK');
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–µ–±—Ö—É–∫–∞:', error);
    res.status(500).send(`–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: ${error.message}`);
  }
}

// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –≤ —Ä–∞–∑–Ω—ã—Ö —Ä–µ–∂–∏–º–∞—Ö
if (IS_VERCEL) {
  // Vercel mode: use webhooks
  if (!WEBHOOK_URL) {
    throw new Error("WEBHOOK_URL –Ω–µ –∑–∞–¥–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –¥–ª—è —Ä–µ–∂–∏–º–∞ Vercel");
  }
  
  console.log(`–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∂–∏–º–µ –≤–µ–±—Ö—É–∫–æ–≤ –Ω–∞ ${WEBHOOK_URL}`);
  
  // –≠–∫—Å–ø–æ—Ä—Ç –¥–ª—è Vercel API endpoint
  module.exports = async (req: any, res: any) => {
    await handleWebhook(req, res);
  };
} else {
  // Local mode: use long polling
  bot.start({
    onStart: (botInfo) => {
      console.log(`–ë–æ—Ç @${botInfo.username} –∑–∞–ø—É—â–µ–Ω –≤ —Ä–µ–∂–∏–º–µ long polling!`);
      console.log(`${BOT_NAME} –Ω–∞ –±–∞–∑–µ ${BOT_PLATFORM}, —Å–æ–∑–¥–∞–Ω –∫–æ–º–ø–∞–Ω–∏–µ–π ${BOT_CREATOR}`);
      console.log(`–†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–π ID –≥—Ä—É–ø–ø—ã: ${ALLOWED_GROUP_ID}`);
    },
  });
}

// Error handling
process.on('uncaughtException', (error: Error) => {
  console.error('–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ:', error);
});

process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
  console.error('–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ:', promise, '–ø—Ä–∏—á–∏–Ω–∞:', reason);
}); 